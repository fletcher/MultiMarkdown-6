\input{mmd6-tufte-handout-leader}
\def\mytitle{MultiMarkdown Usage}
\def\myauthor{Fletcher T. Penney}
\def\revised{2018-10-09}
\newacronym{MMD}{MMD}{MultiMarkdown}

\newacronym{MD}{MD}{Markdown}

\input{mmd6-tufte-handout-begin}

\tableofcontents

\chapter{Usage}
\label{usage}

\section{Basic Command Line Usage}
\label{basiccommandlineusage}

First, verify that you have properly installed MultiMarkdown:

\begin{verbatim}
multimarkdown --version
multimarkdown --v
\end{verbatim}

To learn more about the command line options available:

\begin{verbatim}
multimarkdown --help
multimarkdown --h
\end{verbatim}

To convert a file to HTML:

\begin{verbatim}
multimarkdown file.txt
\end{verbatim}

To save the HTML to a file

\begin{verbatim}
multimarkdown file.txt > file.html
\end{verbatim}

To convert to a different format:

\begin{verbatim}
multimarkdown -t latex file.txt
multimarkdown -t epub file.txt
\end{verbatim}

\section{Batch Mode}
\label{batchmode}

Batch mode allows you to convert one or more files in a single command, saving each file to a separate output file with a file extension based on the output format (e.g. \texttt{.html} or \texttt{.tex}). This will overwrite existing files.

\begin{verbatim}
multimarkdown -b file.txt file2.txt
\end{verbatim}

\section{Transclusion Only}
\label{transclusiononly}

You can output to the \texttt{mmd} format to perform file transclusion and then output the raw \gls{MMD} source before converting to another format:

\begin{verbatim}
multimarkdown -t mmd file.txt
\end{verbatim}

\section{Convenience Scripts}
\label{conveniencescripts}

There are several convenience scripts to batch convert to a specified format:

\begin{verbatim}
mmd file.txt
markdown file.txt		// Compatibility mode
mmd2epub file.txt
mmd2fodt file.txt
mmd2odt file.txt
mmd2opml file.txt
mmd2pdf file.txt		// Convert to LaTeX and process to PDF
mmd2tex file.txt
\end{verbatim}

\section{Advanced Options}
\label{advancedoptions}

\begin{verbatim}
multimarkdown -f, multimarkdown --full
multimarkdown -s, multimarkdown --snippet
\end{verbatim}

Control whether MultiMarkdown outputs a complete document or just a ``snippet''. A snippet includes just the section of text included in the document. A full\slash{}complete document includes header information and other structure to form a complete HTML or LaTeX document, for example. Additionally, if metadata is included (with a few exceptions), MultiMarkdown will automatically produce a complete document.

\begin{verbatim}
multimarkdown -c, multimarkdown --compatibility
\end{verbatim}

Compatibility mode forces MultiMarkdown to create HTML that matches the output of basic Markdown. In other words, it disables all the new features added in MultiMarkdown.

There are a few exceptions, however. The original \texttt{Markdown.pl} script used recursive regular expressions to perform parsing. This is very flexible (though error-prone), but is extremely slow. MultiMarkdown v6 has a \emph{much} faster parser, but there is one key limitation -- it parses in order and can't look ahead indefinitely to see what might be coming up. The main situations where this occurs is in handling fenced code blocks (not a problem in compatibility mode, since they don't exist in Markdown) and in handling raw HTML. For more information on this, see \href{https://github.com/fletcher/MultiMarkdown-6/issues/135}{https:\slash{}\slash{}github.com\slash{}fletcher\slash{}MultiMarkdown-6\slash{}issues\slash{}135}.

The other potential difference is that MultiMarkdown v6 has a smarter strong\slash{}emphasis parser than \texttt{Markdown.pl} -- it better handles edge cases.

Because of these exceptions, there may be a few rare situations where the output generated by MultiMarkdown v6 does not match that by \texttt{Markdown.pl}. If you find what you believe to be a bug that doesn't fit one of these situations, please let me know and I'll take a look. The goal is to match the original Markdown output as much as possible, but not to match the many bugs that are contained in \texttt{Markdown.pl}.

\begin{verbatim}
multimarkdown --random
\end{verbatim}

Normally MultiMarkdown assigns consecutive numbers to the identifiers used for footnotes, citations, etc. (e.g. 1, 2, 3, etc.) This means that you have a ``blog-style'' web site that shows multiple articles on the home page, and multiple stories have footnotes, the anchors will collide. The \texttt{random} option generates random anchor numbers to dramatically reduce the offs of a collision.

\begin{verbatim}
multimarkdown --unique
\end{verbatim}

The \texttt{unique} option uses a similar random number generator to provide unique anchors (``labels'') for headers that do not have a manually specified label. This prevents every ``Introduction'' header in a textbook, for example, from having the identical label \texttt{\#introduction}. This reduces validation errors in HTML, ePub, and LaTeX, and prevents collisions when using the \texttt{\{\{TOC\}\}} function.

\begin{verbatim}
multimarkdown --nosmart
\end{verbatim}

Disable smart quotes (e.g. \texttt{"foo"} does not become \texttt{“foo”}).

\begin{verbatim}
multimarkdown --nolabels
\end{verbatim}

Disables automatic generation of labels\slash{}anchors for headers.

\begin{verbatim}
multimarkdown --notransclude
\end{verbatim}

Disables file transclusion that allows inserting the contents of a file inside another file. See the section on {[File Transclusion]} for more information.

\begin{verbatim}
multimarkdown --opml
\end{verbatim}

Allows MultiMarkdown to read an \href{https://en.wikipedia.org/wiki/OPML}{OPML}\footnote{\href{https://en.wikipedia.org/wiki/OPML}{https:\slash{}\slash{}en.wikipedia.org\slash{}wiki\slash{}OPML}} source file. Outline Processor Markup Language is an XML file format commonly used for outliners and mind mapping programs. MultiMarkdown can read\slash{}write to this format in addition to using regular plain text files.

\begin{verbatim}
multimarkdown --itmz
\end{verbatim}

Similar to OPML, ITMZ is an outlining format specific to the \href{https://www.toketaware.com/}{iThoughts}\footnote{\href{https://www.toketaware.com/}{https:\slash{}\slash{}www.toketaware.com\slash{}}} mind-mapping program. I added this format because:

\begin{enumerate}
\item iThoughts is my preferred mind-mapping tool

\item iThoughts supports OPML, but the support is (unfortunately) limited. I was unable to convince the author of the benefits of better read\slash{}write support for OPML.

\item Adding ITMZ support after adding OPML support wasn't that hard.

\item Adding ITMZ support to MultiMarkdown allows me to do some interesting things in MultiMarkdown Composer, as well as in other workflows. (More to come on that.)

\end{enumerate}

Though I reluctantly added support for this format to MultiMarkdown, I will not be adding support for a laundry list of other formats. Plain text and OPML should be enough. If the use of these outline file formats for MultiMarkdown (or regular Markdown) continues to gain traction, then hopefully other developers will include proper OPML support in their programs.

As an aside, the first use of this functionality came when I created an export plug-in for \href{https://www.omnigroup.com/omnioutliner/}{OmniOutliner}\footnote{\href{https://www.omnigroup.com/omnioutliner/}{https:\slash{}\slash{}www.omnigroup.com\slash{}omnioutliner\slash{}}} that created a plain Markdown\slash{}MultiMarkdown text file when exporting from an Omnioutliner OPML file.

\begin{verbatim}
multimarkdown -t, multimarkdown --to=FORMAT
\end{verbatim}

Specify the output format.

\begin{verbatim}
multimarkdown -o, multimarkdown --output=FILE
\end{verbatim}

Specify the output file name.

\begin{verbatim}
multimarkdown -a, multimarkdown --accept
multimarkdown -r, multimarkdown --reject
\end{verbatim}

Either accept or reject all proposed \href{http://criticmarkup.com/}{CriticMarkup}\footnote{\href{http://criticmarkup.com/}{http:\slash{}\slash{}criticmarkup.com\slash{}}} changes contained within the document before processing. It basically allows you to output a ``before'' and an ``after'' version of a document containing edits. If neither option is used, MultiMarkdown attempts to show the edits in-line, but this is not always possible for poorly structured edits. See the section on \href{http://criticmarkup.com/}{Criticmarkup}\footnote{\href{http://criticmarkup.com/}{http:\slash{}\slash{}criticmarkup.com\slash{}}} for more information.

\begin{verbatim}
multimarkdown -l, multimarkdown --lang=LANG
\end{verbatim}

Localize language\slash{}smart quotes for \texttt{en, es, de, fr, he, nl, sv}. This can also be controlled via metadata.

\begin{verbatim}
multimarkdown -m, multimarkdown --metadata-keys
\end{verbatim}

List all metadata keys contained in the document.

\begin{verbatim}
multimarkdown -e, multimarkdown --extract=KEY
\end{verbatim}

Extract the value of a specified metadata key. This is useful for custom scripts, for example.

\input{mmd6-tufte-handout-footer}
\end{document}
